% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/splice_pipe.r
\name{\%!>\%}
\alias{\%!>\%}
\title{Splice pipe operator}
\usage{
lhs \%!>\% rhs
}
\arguments{
\item{lhs}{List, with elements corresponding to arguments in rhs.}

\item{rhs}{A function or function call.}
}
\value{
The results of rhs, with lhs spliced as arguments.
}
\description{
\code{lhs \%!>\% rhs} splices the elements of lhs into a function or call expression (\code{rhs}).
}
\details{
The splice pipe takes a named list on the left hand side and inserts
  the arguments in the right with the rlang splice operator (\link[rlang]{!!!}).
  Unlike normal use of (\link[rlang]{!!!}), \code{\%!>\%} is compatable with
  functions that don't accept tidy dots.
}
\examples{
 list(1:20, na.rm = TRUE) \%!>\% sum
 # These will produce the same result:
 list("A", b = "B") \%!>\% test_fun
 list("A", b = "B") \%!>\% test_fun()

 # You can also specify arguments in the rhs function call
 list("A", b = "B") \%!>\% test_fun(d = 12)

 # The lhs positional arguments take precedence, with the
   # rhs positional arguments filling the next available slot
 list("A", b = "B") \%!>\% test_fun("This is C", d = 12)

 # Named arguments on the rhs take precedence and produce a warning
 list("A", b = "B", d = "nope") \%!>\% test_fun("C", d = 12)

\dontrun{
 # This will fail because the "C" argument can't go anywhere
 list(a = "A", b = "B", c = "nope") \%!>\% test_fun("C", d = 12)
 }

 # You can use annonymous functions,
 #   but they need to be wrapped in braces
 list(a = "A", b = "B") \%!>\% {function(a, b, ...) paste(a,b)}

   # rlang lambda functions also need to be wrapped in braces
 list(.x = "A", .y = "B") \%!>\% {~paste(.x, .y)}

 # The splice pipe can also be used to work with S3 outputs
\dontrun{
 lm(Sepal.Length ~ Sepal.Width, data = iris) \%!>\% {
   function(fitted.values, residuals, ...){
     plot(fitted.values, residuals)
     invisible(list(...))
   }
 } }

 # You can force the evaluation of an rhs function factory
 # before splicing by wrapping it in parentheses.
 # The resulting function will then be spliced.
 foo = function(a) {
   function(b, c=5) {a + b + c}
 }
 foo(a = 1)(2) # is the same as
 list(b = 2) \%!>\% (foo(a = 1))
 foo(5)(3,9) # is the same as
 list(b = 2) \%!>\% (foo(3)(c = 9))
}
